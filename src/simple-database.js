/**
 * Simple Database Manager - Version Serverless pour Vercel
 * Gestion SQLite simplifi√©e avec gestion des erreurs de dossiers
 */

const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const fs = require('fs');

class SimpleDatabase {
    constructor() {
        this.db = null;
        this.dbPath = './data/shaders.db';
        this.isInitialized = false;
    }

    async initialize() {
        try {
            console.log('üöÄ Initialisation de la base de donn√©es...');
            
            // V√©rifier si on est sur Vercel (environnement serverless)
            const isVercel = process.env.VERCEL === '1';
            
            if (isVercel) {
                console.log('üåê Environnement Vercel d√©tect√© - Utilisation de la m√©moire');
                // Sur Vercel, utiliser une base de donn√©es en m√©moire
                this.dbPath = ':memory:';
            } else {
                // En local, cr√©er le dossier data s'il n'existe pas
                try {
                    const dataDir = path.dirname(this.dbPath);
                    if (!fs.existsSync(dataDir)) {
                        fs.mkdirSync(dataDir, { recursive: true });
                        console.log('üìÅ Dossier data cr√©√©');
                    }
                } catch (error) {
                    console.log('‚ö†Ô∏è Impossible de cr√©er le dossier data, utilisation de la m√©moire');
                    this.dbPath = ':memory:';
                }
            }

            // Cr√©er la connexion √† la base de donn√©es
            this.db = new sqlite3.Database(this.dbPath, (err) => {
                if (err) {
                    console.error('‚ùå Erreur connexion base de donn√©es:', err);
                    throw err;
                }
                console.log('‚úÖ Connect√© √† la base de donn√©es SQLite');
            });

            // Cr√©er les tables
            await this.createTables();
            this.isInitialized = true;
            console.log('‚úÖ Base de donn√©es initialis√©e avec succ√®s');
            
        } catch (error) {
            console.error('‚ùå Erreur initialisation base de donn√©es:', error);
            // En cas d'erreur, utiliser une base en m√©moire
            try {
                this.dbPath = ':memory:';
                this.db = new sqlite3.Database(this.dbPath);
                await this.createTables();
                this.isInitialized = true;
                console.log('‚úÖ Base de donn√©es en m√©moire initialis√©e');
            } catch (fallbackError) {
                console.error('‚ùå Erreur fatale base de donn√©es:', fallbackError);
                throw fallbackError;
            }
        }
    }

    async createTables() {
        return new Promise((resolve, reject) => {
            const createShadersTable = `
                CREATE TABLE IF NOT EXISTS shaders (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    code TEXT NOT NULL,
                    user_id TEXT NOT NULL,
                    user_name TEXT NOT NULL,
                    image_path TEXT,
                    likes INTEGER DEFAULT 0,
                    views INTEGER DEFAULT 0,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `;

            const createUsersTable = `
                CREATE TABLE IF NOT EXISTS users (
                    id TEXT PRIMARY KEY,
                    username TEXT NOT NULL,
                    total_shaders INTEGER DEFAULT 0,
                    total_likes INTEGER DEFAULT 0,
                    last_seen DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `;

            this.db.exec(createShadersTable + createUsersTable, (err) => {
                if (err) {
                    console.error('‚ùå Erreur cr√©ation tables:', err);
                    reject(err);
                } else {
                    console.log('‚úÖ Tables cr√©√©es avec succ√®s');
                    resolve();
                }
            });
        });
    }

    async saveShader(shaderData) {
        return new Promise((resolve, reject) => {
            if (!this.isInitialized) {
                reject(new Error('Base de donn√©es non initialis√©e'));
                return;
            }

            const { code, userId, userName, imagePath } = shaderData;
            const stmt = this.db.prepare(`
                INSERT INTO shaders (code, user_id, user_name, image_path)
                VALUES (?, ?, ?, ?)
            `);

            stmt.run([code, userId, userName, imagePath], function(err) {
                if (err) {
                    console.error('‚ùå Erreur sauvegarde shader:', err);
                    reject(err);
                } else {
                    console.log('‚úÖ Shader sauvegard√© avec ID:', this.lastID);
                    resolve(this.lastID);
                }
            });

            stmt.finalize();
        });
    }

    async updateUserStats(userId, userName) {
        return new Promise((resolve, reject) => {
            if (!this.isInitialized) {
                reject(new Error('Base de donn√©es non initialis√©e'));
                return;
            }

            const stmt = this.db.prepare(`
                INSERT OR REPLACE INTO users (id, username, last_seen)
                VALUES (?, ?, CURRENT_TIMESTAMP)
            `);

            stmt.run([userId, userName], (err) => {
                if (err) {
                    console.error('‚ùå Erreur mise √† jour utilisateur:', err);
                    reject(err);
                } else {
                    resolve();
                }
            });

            stmt.finalize();
        });
    }

    async getPopularShaders(limit = 5) {
        return new Promise((resolve, reject) => {
            if (!this.isInitialized) {
                reject(new Error('Base de donn√©es non initialis√©e'));
                return;
            }

            const query = `
                SELECT * FROM shaders 
                ORDER BY likes DESC, views DESC 
                LIMIT ?
            `;

            this.db.all(query, [limit], (err, rows) => {
                if (err) {
                    console.error('‚ùå Erreur r√©cup√©ration shaders populaires:', err);
                    reject(err);
                } else {
                    resolve(rows || []);
                }
            });
        });
    }

    async searchShaders(query, limit = 5) {
        return new Promise((resolve, reject) => {
            if (!this.isInitialized) {
                reject(new Error('Base de donn√©es non initialis√©e'));
                return;
            }

            const searchQuery = `
                SELECT * FROM shaders 
                WHERE code LIKE ? OR user_name LIKE ?
                ORDER BY created_at DESC 
                LIMIT ?
            `;

            const searchTerm = `%${query}%`;
            this.db.all(searchQuery, [searchTerm, searchTerm, limit], (err, rows) => {
                if (err) {
                    console.error('‚ùå Erreur recherche shaders:', err);
                    reject(err);
                } else {
                    resolve(rows || []);
                }
            });
        });
    }

    async getStats() {
        return new Promise((resolve, reject) => {
            if (!this.isInitialized) {
                reject(new Error('Base de donn√©es non initialis√©e'));
                return;
            }

            const queries = {
                totalShaders: 'SELECT COUNT(*) as count FROM shaders',
                totalUsers: 'SELECT COUNT(*) as count FROM users',
                totalLikes: 'SELECT SUM(likes) as total FROM shaders'
            };

            const stats = {};
            let completed = 0;
            const totalQueries = Object.keys(queries).length;

            Object.entries(queries).forEach(([key, query]) => {
                this.db.get(query, (err, row) => {
                    if (err) {
                        console.error(`‚ùå Erreur statistique ${key}:`, err);
                        stats[key] = 0;
                    } else {
                        stats[key] = row.count || row.total || 0;
                    }
                    
                    completed++;
                    if (completed === totalQueries) {
                        resolve(stats);
                    }
                });
            });
        });
    }

    async close() {
        return new Promise((resolve) => {
            if (this.db) {
                this.db.close((err) => {
                    if (err) {
                        console.error('‚ùå Erreur fermeture base de donn√©es:', err);
                    } else {
                        console.log('‚úÖ Base de donn√©es ferm√©e');
                    }
                    resolve();
                });
            } else {
                resolve();
            }
        });
    }
}

module.exports = { SimpleDatabase };
